
# 模板



**时间**：
**杂志**：
**摘要**：

**关键词**：

# Software Reliability Engineering - A Review软件可靠性工程-回顾
软件可靠性工程-回顾

**时间**：2011年9月
**杂志**：International Journal of Applied Physics and Mathematics
**摘要**：
略
**关键词**：
reliability， waterfall ，prototyping ，incremental，rapid，evolutionary，agile
可靠性，瀑布模型，原型制作，增加的，快速，进化，敏捷

## 总结

1. 里面有传统可靠性的浴盆曲线和理想化的软件可靠性曲线。
2. 有常见的软件开发模型的简介，有瀑布模型、原型制作、增量开发、螺旋发展、快速应用开发（RAD）、进化发展方法、Rational统一过程、基于组件的软件开发。
3. 有计算机辅助软件工程、IDE、敏捷开发（极限编程XP、Scrum）的简介。
4. 至于文章本身提出的那个东西，就是说要先建模算一算可靠性，直接算可能有困难。但是啥有用的东西都没有。

# Deterministic Models of Software Aging and Optimal Rejuvenation Schedules软件老化和最佳复兴计划的确定性模型
软件老化和最佳复兴计划的确定性模型

**时间**：2007
**杂志**：
**摘要**：
研究对象：服务器Axis Soap Server 1.3
对老化建模，从而进行Rejuvenation。SLA约束、

建模算法：样条插值拟合
**关键词**：

## 总结

1. 在介绍中提到了老化、Rejuvenation的介绍，两种基本的Rejuvenation思路：定时，积极（根据建模）。
2. 用某些指标来评价老化：服务器每秒可处理的最大请求数。
3. 假设性能下降与负载有关的函数。假设模型可以足够精确的建模。
4. 介绍了建模思路：分析建模和基于度量建模
5. 建模过程：分段用样条拟合
6. 假设老化指标只取决于单个负载指标。或者多个负载指标的简单函数。
7. 用方差分析进行了模型验证
8. 改进了方差分析法，引入了方差容忍度
9. 分析了如何得出最佳Rejuvenation的时间，此处没有细看
10. 实验通过10台客户端连接1台服务器来注入负载。
11. 收集的系统参数有：
  + free memory：available memory in the JVM of the SOAP
server
  + cpu_user： % of CPU time used by the user applications,
  + cpu_system：操作系统使用的CPU时间的百分比，
  + cpu_idle：CPU空闲的时间的百分比，
  + request_per_sec：SOAP服务器的吞吐量，以每秒执行的请求数为单位，
  + min_lat：请求延迟最小观测值
  + maxlat：请求延迟最大观测值
  + avg lat：请求延迟平均值。
12. 实验方法：以超过服务器容量的某一个固定值持续加压
13. 老化指标：每秒请求数。负载指标：经选择，用了自上次重启以来的请求数。
14. 图像的曲线都是很平滑的，先上升，然后缓慢单调下降的样子。【随着总请求数越来越多，每秒的请求就越小，老化了。】

# Basic Concepts and Taxonomy of Dependable and Secure Computing可靠和安全计算的基本概念和分类
可靠和安全计算的基本概念和分类

这篇好像是大佬的综述
**时间**：2004
**杂志**：IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING, VOL. 1, NO. 1, JANUARY-MARCH 2004 
**摘要**：
就是各种定义。
**关键词**：
Dependability, security, trust, faults, errors, failures, vulnerabilities, attacks, fault tolerance, fault removal, fault forecasting
可靠性，安全性，信任性，故障，错误，故障，漏洞，攻击，容错，故障消除，故障预测
## 总结

非常详尽的定义

# Detecting Application-Level Failures in Component-Based Internet Services在基于组件的Internet服务中检测应用程序级故障
在基于组件的Internet服务中检测应用程序级故障

作者一个是斯坦福的，一个是MIT的
**时间**：2005
**杂志**：IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 16, NO. 5, SEPTEMBER 2005 
**摘要**：
大多数Internet服务（电子商务，搜索引擎等）都存在故障。
快速检测这些故障可能是提高系统可用性的最大瓶颈。
我们介绍方法Pinpoint，一种通过以下方法在Internet服务中自动进行故障检测的方法：1）观察服务的底层内部结构行为； 2）将系统的多数行为建模为正确； 3）将这些行为中的异常检测为故障的可能症状。
不需要任何先验的特定于应用程序的信息，Pinpoint在我们的实验中正确地检测出了89％–96％的重大故障，与此同时，当前的通用应用技术检测出了20％–70％。
**关键词**：
Anomaly detection, application-level failures, Internet services.
异常检测，应用程序级别的故障，Internet服务。

## 总结

1. 研究的是应用程序级的故障：会影响用户可见的一些功能，但是不会引起系统崩溃一类的运营商可检测到的系统级故障
2. 无需先验信息，对正常状态进行建模。
3. 监控内部组件的trace形状：客户请求后经过的部件名称。监控部件之间的交互情况。
4. 实验对象：J2EE应用程序
5. 主要关注在故障发生后尽快检测到
6. 监测方法：写在了J2EE上
7. 故障注入研究，参考文献4,18-21，列举了一部分，没有详细步骤
8. 计算P的时候通过min(0, score-a)过滤掉大于a的一些值
9. 组件交互的计数与请求路径分析有一定程度上的互补。
10. 用PCFG对路径进行了建模，从这里就与我的研究无关了。
11. 本篇有简略译文。


# A Measurement-Based Model for Estimation of Resource Exhaustion in Operational Software Systems基于测量的运营软件系统资源枯竭估计模型
基于测量的运营软件系统资源枯竭估计模型

**时间**：1999
**杂志**：
**摘要**：

主要研究软件老化。本文考虑了系统的工作负荷，函数的自变量之一。本文提出了一个基于度量的模型，来估计操作系统资源的耗尽率，自变量为时间和工作负载状态。用基于Unix系统收集到的工作量和资源使用情况构建了半马尔科夫奖励模型。先用统计聚类分析对工作量的状态进行了聚类，然后根据每种在不同状态下的资源枯竭率，为该模型定义奖励函数。然后求解该模型以获得**趋势**以及资源的估计**耗尽率**和**耗尽时间**。


**关键词**：

## 总结

1. 研究老化，主要原因：操作系统资源的耗尽，数据损坏和数字错误累积。导致系统崩溃或挂起。
2. 常见情况：**内存膨胀和泄漏**，**未释放的文件锁**，数据损坏，存储空间碎片以及舍入错误的累积
3. 预测资源消耗的时候考虑了工作负载。
4. 相关工作中提到：
   1. 时间为变量预测系统资源的方法
   2. 有一些文献说明了资源、负载与失效的相关性。
   3. 别的工作负载指标：CPU使用率、内存使用率
   4. 性能的单词用了performability
5. 马尔科夫不太懂，没有细看。简单的说，应该是预测一个状态到另一个状态转换的概率。
6. 10分钟一次，监控了3个月：系统资源状态、进程状态、文件系统信息【/tmp】、网络相关、磁盘IO，共100多个此类参数【和sar的差不多，只不过多了进程信息？】
7. 要预测的值：usedSwapSpace和realMemoryFree。建模用的数据是最长的采样时间内的数据【重启或发生了故障则重新采样】
8. 工作负载的表示：工作负载与CPU和I/O有关，故采用cpuContextSwitch【测量间隔内，进程的上下文切换数量】、sysCall【系统调用数】、pageIn【从文件系统或交换设备分页的页面数，就叫page-in】、pageOut
9. 对于每个工作负载的点【相当于一个四维空间的点】进行聚类，算法用的Hartigan【一种k-means聚类算法】。聚类发现一些状态时轻量工作状态，一些是高负载。
10. 计算状态转移概率【通过简单除法】，构建转移矩阵。半马尔科夫好像还要状态持续时间，反正根据分布大概定了一个？然后验证了一下结果，效果很不错。
11. 这里有点看不懂了，反正是通过奖励函数，利用半马尔科夫模型对要预测的两个值进行了预测
12. 计算斜率的方法[20]：这个斜率好像是大量样本的总斜率，跟我要的不一样。
13. 最后这个结果有点迷，看不懂


# A Best Practice Guide to Resource Forecasting for Computing Systems计算系统资源预测的最佳实践指南
计算系统资源预测的最佳实践指南

**时间**：2007
**杂志**：
**摘要**：
在本文中，我们基于预测Apache Web服务器性能变量以及预测实际电信系统的呼叫可用性的经验，提出了建立经验模型的最佳实践指南。为了证实所提供的指南，并逐步演示我们的方法，我们对**响应时间**，Apache Web服务器系统的**可用物理内存**量以及工业电信系统的呼叫call可用性进行建模和预测。此外，我们为a）基准交叉验证三个**变量选择**的方法，b）基准交叉验证四个**经验模型构建**的方法以及c）**敏感性分析**  提供了具体的结果。本最佳实践指南旨在协助系统地配置建模方法，以实现最佳估计和预测结果。

**关键词**：
Apache web server, failure forecasting, monitoring,
non-parametric modeling, prediction of resource utilization,
quantitative analysis, statistical modeling, telecommunication
systems.

Apache Web服务器，故障预测，监视，非参数​​建模，资源利用预测，定量分析，统计建模，电信系统。

## 总结

1. 本篇文献非常有用，基本上阐述了在当时的常用方法，并进行了总结，还有完整的实验和分析
2. Introduction里的很多也非常有用，可以直接用
3. 补丁、更新会把测试过的系统编程未测试的系统，引入新的错误，所以需要预测
4. 预测了Apache服务器中的响应时间和可用物理内存。电信系统的那个例子没细看。
5. 主要过程：数据选择【向前选择，向后消除，PWA概率包装】，建模【**多元线性回归、UBF、RBF、SVM**】，敏感性分析【删除一个看看模型的指标怎么样，后来发现敏感性与目标值的相关性关系不大】
6. 选择好的数据子集要比选模型重要的多
7. 介绍了大量之前别人用过的模型，文献
8. 数据集分成了三份，【按时间分的？从图上看是这样的】将第一段用于参数化模型，第二部分对模型进行交叉验证并限制过度拟合，第三部分用于对模型的泛化性能进行评估。一二段都喂给模型
9. 数据有峰值，处理方法：一段时间窗口内的中位数median，感觉平均值也行？或者就是平均值？
10. 数据：系统变量一类的和网络相关的，还有一阶导数
11. 响应时间预计：
    1. 实际数据：整体缓慢上升，有非常多的峰值，整体是个锯齿
    2. 中位数处理后，整体单调上升，最后一段略微下降一点点就平了
    3. 大概每6h有一次峰值
    4. 短期预计选出来的变量有：
       1. 新进程数
       2. 硬盘写入块数
       3. eh0_trans_pkts
       4. lo_recv_pkts
       5. SwapOutCounter
       6. si_slab_cache
       7. si_size_256
       8. ContextSwitches的导数
       9. CachedMemory的导数
    5. 长期的变量有：
       1. 新进程数
       2. eh0_recv_pkts
       3. ContextSwitches
       4. TimeIdelMode
       5. io_trans_bytes
       6. SwapInCounter
       7. si_size_256
       8. si_size_32
       9. ContextSwitches的导数
12. 可用内存预计
    1. 数据趋势：先下降，然后到一个地方后开始上升
    2. 变量有：
       1. t-1时刻的可用物理内存
       2. TimeUserMode
       3. 新进程数的导数
       4. si_files_cache

# Quantifying Temporal and Spatial Correlation of Failure Events for Proactive Management量化故障事件的时间和空间相关性以进行主动管理

量化故障事件的时间和空间相关性以进行主动管理

**时间**：2007
**杂志**：
**摘要**：

故障事件在时空方面表现出很强的相关性。 在本文中，我们开发了具有可调时标参数的**球形协方差模型**以量化时间相关性，并建立了随机模型以表征空间相关性。 进一步扩展了模型，以考虑到应用程序分配的信息，以发现故障实例之间的更多关联。 我们根据故障事件的相关性对它们进行聚类，并预测其未来的发生。
在生产联盟系统Wayne State Grid上的实验结果表明，我们的预测系统进行的离线和在线预测可以预测72.7％至85.3％的故障发生，并捕获集群联盟环境中的故障相关性。

**关键词**：

## 总结
1. 主要考虑的是故障之间的时间相关性和空间相关性
2. 时间相关性：a.短时间内多个节点同时发生一个故障；b.故障在解决前多次出现
3. 空间相关性：a.故障几乎同时发生在多个节点上【一个程序要用多个节点，有bug都得坏】；b.节点故障会导致别的节点的另一种故障【一个坏了会传错误数据】
4. 实验对象，他们学校的一个计算集群，最小单位就是一台计算机……
5. 收集的信息：失效签名：内存、CPU、I/O、包
6. 聚类算法？
7. 失效是个重尾分布，而且软件故障最严重（相比于硬件和全部）
8. 时间相关性：用时间差衡量距离，定义了一个球形协方差矩阵【没看懂】
9. 空间相关性：主要是计算失效数，拿概率算的。
10. 离线预计算法4+1：MEAN：以先前度量的平均值作为预测；  LAST：使用最后一个度量；  AVE（n）：使用最近n个小节的平均值；  AR（m）：是自回归的； 一种人工神经网络算法NN（n），使用最后n个数据来更新神经网络并预测故障【3个隐藏层】。
11. 在线预计：拿0~t的数据来预测，然后对比t~T的结果。

# Online Reliability Prediction via Motifs-Based Dynamic Bayesian Networks for Service-Oriented Systems面向服务的系统通过基于Motifs的动态贝叶斯网络进行在线可靠性预测
面向服务的系统通过基于Motifs的动态贝叶斯网络进行在线可靠性预测


**时间**：2016
**杂志**：IEEE Transactions on Software Engineering
**摘要**：

面向服务的系统系统（SoS）将系统视为服务，并通过服务组合技术外包外部组件系统来构建健壮的增值SoS。 为了应对在动态和不确定的运行环境下运行的松耦合SoS，为确保整体服务质量（QoS）的目的而对组件系统进行在线可靠性预测通常是一个重大挑战。 这也是通过优化服务选择以确保可靠的系统构建来保证SoS的运行时QoS的前提。 我们为面向服务的SoS中的组件系统提出了一种新颖的在线可靠性时间序列预测方法。 我们利用概率图形模型（PGM）来产生接近未来的时间序列预测。 我们通过从广泛使用的真实Web服务中收集的调用记录来评估该方法。 实验结果证实了该方法的有效性。


**关键词**：Index Terms—Online reliability prediction, time series, service-oriented computing, system of systems

索引词-在线可靠性预测，时间序列，面向服务的计算，系统系统

## 总结

1. 本文没有详细阅读
2. 主要是针对System of Systems，好像会有一些独特的问题，本文重点在预测可靠性
3. 在线可靠性时间序列预测
4. 历史参数：响应时间，吞吐量，可靠性，用概率图像模型PGM分析。对历史参数预处理，分成等长的时间序列。然后用主题的概念来描述时间序列的模式。然后用马尔科夫表达序列间的关系，生成条件概率表CPT，CPT与PGM一起用于预测。主要是基于动态贝叶斯网络，整合了时间序列。
5. 论文15中有简要介绍





# Seer: A Lightweight Online Failure Prediction Approach 一种轻量级的在线故障预测方法
Seer：一种轻量级的在线故障预测方法

**时间**：2017
**杂志**：IEEE Transactions on Software Engineering
**摘要**：

**关键词**：

## 总结
1. 从程序内部收集信息会产生过多的运行时开销，所以现有方法通常会避免使用
2. Seer是通过硬件性能计数器（HPC）来收集数据的，在硬件层面收集数据，如CPU驻留计数器来收集执行的指令数和采取的分支数量
3. 与此同时还可以结合系统层次收集到的进程数、CPU、内存、网络利用率来加强预测效果。【这个他好像没做，看了眼图，确实没有】
4. 现在大部分的预测都是把软件当黑盒子，可以考虑白盒拿到更内部的数据。不这么做的主要问题是开销太大。
5. 本文未精读。
6. 先把历史数据输入，然后选出一些可以在运行时监控的函数，然后从这些函数的历史数据里收集信息，用于识别出一些候选函数。然后再在候选函数里选，选出seer函数，用seer函数预测。
7. 过滤历史数据：1. 过滤掉error级别的，因为这时候已经发生了，该函数对预测没啥用。2. 过滤掉执行次数太多的，考虑开销
8. 筛选变量：对每一个函数都构建了一个决策树，然后把F值高的留了下来
9. 滑动窗口：函数做出的一系列的预测用于分析。背后可能的原理[34]：程序中的缺陷会不断地传播，感染更多的程序状态，那么一段时间内的一系列预测可以提高预测准确性。随着时间流逝，与正常值的偏差可能增加。
10. 每个seer函数在调用后都会给个预测值，T或F，一个执行的所有预测值叫health index
11. 滑动窗口是用每个seer函数的最后l个预测值去预测会不会失效。然后把窗口内的分数做个加和这样。
12. 感觉很有趣的东西，没时间细看了。
13. TOT_INS计算执行的机器指令的数量。BRN_TKN计算采取的分支数。LST_INS对执行的加载和存储存储器指令的数量进行计数。

# DAC-Hmm: detecting anomaly in cloud systems with hidden Markov models    DAC-Hmm：使用隐藏的马尔可夫模型检测云系统中的异常

**时间**：2015
**杂志**：
**摘要**：
云计算系统的异常检测解决方案必须在运行时运行，而且不需要事先了解正常或异常行为。 本文提出了一种基于隐马尔可夫模型的无监督在线异常检测方案。 我们的算法基本上是分布式的，并在云上的每台计算机上本地运行，以实现高可扩展性。 在真实数据集上进行的实验证实了以下事实，即我们的算法可以为一系列系统异常实现高检测精度，而对云基础架构的开销却很小。 
**关键词**：

## 总结
我感觉这个跟我没啥关系，云计算，黑盒的，而且还是无监督异常检测，不是预计

# The Time Dimension in Predicting Failures: a Case Study预测故障的时间维度：一个案例研究

**时间**：2013
**杂志**：
**摘要**：

**关键词**：
## 总结
1. 这篇文章复制不了，好坑
2. 时间窗口

# Fundamental Concepts of Dependability

**时间**：2001
**杂志**：
**摘要**：

**关键词**：

## 总结
和可靠性，故障，失效有关的一些概念。

# A Survey of Online Failure Prediction Methods
重要！！！

**时间**：
**杂志**：
**摘要**：

**关键词**：

本文有目前的方法分类，还有一个大表格，非常有用，之后整理出来。整理出来发现没啥用……



# A Survey of Software Aging and Rejuvenation Studies软件老化和复兴研究概述

**时间**：
**杂志**：
**摘要**：

**关键词**：

## 总结
1. 预测值与真实值的差是不是也可以用，有文章用此作为了开始老化的起点现象。 
2. 记得考虑负载的问题。

# Towards assessing representativeness of fault injection-generated Failure Data for Online Failure Prediction面向评估故障注入生成的故障数据的代表性，以进行在线故障预测

**时间**：2015
**杂志**：
**摘要**：

**关键词**：

注入的软件故障是否有代表性是最后生成的故障数据有效的一个必要条件。生成的故障相关的数据的代表性依旧是个仍未解决的问题。在这项工作中，我们提出了使用G-SWFIT逼真的软件故障注入技术来评估故障相关数据的代表性的初步研究。我们在这里解决代表性估计和评估的概念和度量标准的定义。

## 总结

1. 主要研究的是软件注入的故障是否有代表性的问题。
2. 提到了G-SWIFT：通用软件故障注入技术。Time Domain那篇文章也是用的这个。



   [11] J. A. Duraes and H. S. Madeira, “Emulation of software faults: A
field data study and a practical approach,” IEEE Trans. Softw. Eng.,
pp. 849–867, 2006.

   

![image-20200528120319033](C:\Users\55012\AppData\Roaming\Typora\typora-user-images\image-20200528120319033.png)

![image-20200528120331247](C:\Users\55012\AppData\Roaming\Typora\typora-user-images\image-20200528120331247.png)


# A Machine Learning-based Framework for Building Application Failure Prediction Models基于机器学习的框架，用于构建应用程序故障预测模型
基于机器学习的框架，用于构建应用程序故障预测模型

**时间**：2015
**杂志**：
**摘要**：

$$F^2PM$$,Framework for building Failure Prediction Models。

一个基于机器学习的框架，用来预测RTTF：the Remaining Time to Failure。

F2PM用系统参数来构建，故与应用程序无关。

F2PM可以选择与失效更相关的系统参数来建模。同时输出一套指标，用于度量模型的好坏，包括模型的准确度和构建时间等。

**关键词**：

## 总结

1. 主要考虑的是内存泄漏和线程未终止
2. 主要思路：收集系统参数，然后用多个机器学习方法进行预测，提供评估指标供用户挑选。
3. 收集的参数：
   1. Tgen是表示自系统启动以来经过的时间的时间戳。  
   2. nth是系统中活动线程的数量；  
   3. Mused是系统中运行的应用程序使用的内存量；  
   4. Mfree是可供应用程序免费使用的内存量； 
   5. Msharedis用于应用程序共享的缓冲区的内存量；  
   6. Mbuff是底层操作系统用于缓冲数据的内存量；  
   7. Mcached是用于缓存磁盘数据的内存量；  
   8. SWused是当前使用的交换空间量；  
   9. SWfree是交换空间的数量，当前可用；  
   10. CP Uus是专用于用户空间进程的CPU时间的百分比；  
   11. CP Uni是具有正尼斯值（较低的调度优先级）的用户级进程占用的CPU时间的百分比；  
   12. CP Usysis在内核模式下花费的CPU时间的百分比； 
   13. CP Uiowis等待I / O操作完成所花费的CPU时间的百分比；  
   14. CP Ust是虚拟机管理程序为另一个虚拟处理器提供服务时，虚拟CPU等待实际CPU的时间百分比。  
   15. CP Uid是完成无效工作（即系统负载不足）所花费的CPU时间的百分比。
4. 数据处理：
   1. 对一个时间窗口内的数据进行了聚合（平均值）：减少数据量，加快训练；消除掉因为操作系统调度引起的单个数据点上的偏差
   2. 对一个时间窗口的数据算了斜率，简单的用最两边的数据：认为崩溃点附近斜率会更大？
   3. 计算了每个数据收集时间戳的间隔，间隔会变化，增大。并与客户端的响应时间呈现强正相关。可以用间隔来拟合响应时间，从而无需对客户端进行修改。同时也可以对失效的判定进行微调。
   4. 特征选择：岭回归【Lasso Regularization】

5. 使用的模型：
   1. 线性回归
   2. M5P：具有线性回归可能性的决策树
   3. REP-Tree：快速决策树
   4. Lasso
   5. SVM
   6. 最小二乘支持向量机
6. 故障注入
   1. 认为生成内存泄漏和未终止的线程
   2. 内存泄漏：定期分配可变大小的连续内存块，并将虚拟内存写入。
   3. 内存泄漏的注入：用2种分布来注入：正态分布来定义每次泄漏的小打、指数分布用于定义内存泄漏的间隔时间
   4. 未终止线程的时间间隔：指数分布
   5. 分布参数用户定义
7. 时间收集的间隔大约是1.5s【会因为CPU的调度和工作负载有变化】
8. 数据传输：TCP/IP协议传输到另一台机器上
9. 一台机器用来发请求，并且记录响应时间；另一台机器搭建一个网页服务器，然后在每次请求的时候，概率性的泄漏内存或生成新线程。
10. 每次崩溃的时候，服务器虚拟机自动重启。收集一周的数据
11. 当RTTF很大的时候，预测的值会偏小。作者认为是因为当故障不断累积的情况下，性能下降，从而导致异常发生率降低，从而实际时间会变长。
12. 不过在RTTF比较小的时候，预测的值都还不错。
13. 模型评估用的S-MAE，会忽略低于阈值的误差

# 面向Xen的软件故障注入方法研究与应用

**时间**：2017
**杂志**：南京理工硕士论文
**摘要**：

**关键词**：

## 总结

没看懂……总感觉没啥用
Ferrari[21】是美国德克萨斯大学奥斯汀分校研发的故障注入工具，是一种针对单机
环境下基于软件的故障注入工具。Xception[23]是一款商用软件，通过被测进程自
带的计数器和计时器触发故障注入，特点是实施故障注入不需要修改SUT。
FTAPE[22】实现了针对多种计算功能部件，如CPU、内存和IO等的故障注入，且
实现了多种故障模型，如针对CPU的故障模型有寄存器单粒子／多粒子翻转，寄
存器传值错误等。DOCTORC20]由美国密歇根大学研发，可以根据潜在的故障模
型或基于历史数据对系统进行故障注入。而且对分布式系统有较强支持。
DEFINE[19】由美国伊利诺伊大学开发，用来评估系统可靠性，故障传播及验证系
统容错性。DEFINE由FINE[18】扩展而成，对分布式系统有较强支持，相比于大
多数故障注入工具，其特点是较轻量。


# 软件故障注入关键技术研究

**时间**：2011
**杂志**：哈工大硕士论文
**摘要**：

**关键词**：

## 总结

也很复杂……
主要是想用于测试，不同测试阶段用了不同的注入方法，感觉没啥用

# Fault Injection Methodology and Tools故障注入方法和工具

北航17系

**时间**：2011
**杂志**：
**摘要**：
抽象
故障注入已被认为是评估计算机系统可靠性的强大技术。 本文介绍了故障注入的概念和原理。 详细介绍了几种故障注入技术及其工具。
故障注入； 依赖; 硬件故障注入； 软件故障注入； 基于VHDL的故障注入； 运行时重新配置

**关键词**：

## 总结

这大概就是传说中北航水的垃圾论文了。


a）由德克萨斯大学奥斯汀分校开发的Ferrari [1]使用软件陷阱来注入CPU，内存和总线故障。  
b）由密歇根大学开发的Doctor [9]允许注入CPU故障，内存故障和网络通信故障。 它使用上述所有三种触发方法来触发故障注入。  
c）Xception [10]是由葡萄牙科英布拉大学开发的，它利用了许多现代处理器中存在的高级调试和性能监视功能来注入更多实际的故障。 软件方法具有许多优点。  


# Emulation of Software Faults: A Field Data Study and a Practical Approach仿真软件故障：现场数据研究和实用方法G-SWIFT

**时间**：2006
**杂志**：
**摘要**：

故障注入已被广泛用于评估容错机制并评估计算机系统中故障的影响。 然而，对软件故障的注入不像其他类型的故障（例如，硬件故障）那样好理解。在本文中，我们分析了如何以与源代码无关的方式注入（仿真）软件故障。 我们专门解决重要的仿真要求，例如故障代表性和仿真精度。 我们从分析大量实际软件故障开始。 我们观察到，很大一部分故障属于定义明确的类别，并且可以用非常精确的方式进行表征，从而可以通过一小组仿真操作员来精确地仿真软件故障。 提出了一种新的基于仿真算子的软件故障注入技术（G-SWFIT）。 该技术包括在机器代码级别上查找可以模拟高级软件故障的关键编程结构。 显示了该技术的故障仿真精度。 这项工作还包括对可能影响技术准确性的关键方面的研究。 还讨论了该技术的可移植性，结果表明可以实现高度的可移植性。

**关键词**：

Fault injection, software faults, software reliability.
故障注入，软件故障，软件可靠性。

## 总结

1. 主要想解决没有源码的情况下，如何去更好的故障注入。
2. 对ODC进行了拓展，以用于故障注入
3. 分析了12个C语言软件中的668个故障，软件类型覆盖了方方面面。
4. 希望注入的故障是：编码中引入，且未能在测试中发现的。
5. 后面的东西就只是大概看了一下。
6. 根据ODC的故障分类，选出了5个，去掉了实验软件中不存在的那2种，然后再考虑三类：缺少代码块，错误代码块，多余代码块。进行正交，一共15种，然后分析数量，最后剔除掉非常少的，选出了数量比较多且普遍存在的几种。
7. 注入的具体方法用到了反编译，在汇编语言的层面上去注入。
8. 注入的故障可能会：不导致失效，导致失效并报告，导致失效无错误信息，超时引起系统挂起
9. 我的实验要注入的应该起码得编译过得去的吧？
10. 本文有机翻文件
11. 本文非常有价值

# Data Stream Clustering for Online Anomaly Detection in Cloud Applications数据流聚类，用于云应用程序中的在线异常检测

**时间**：2015
**杂志**：
**摘要**：

摘要—本文介绍了一种在线检测云虚拟机（VM）中性能异常的新方法。 它是专为云基础架构提供商设计的，用于在运行时检测未知异常，这些异常仍可能在VM托管的复杂现代系统中观察到。 该方法基于每个VM监视数据的数据流群集，并以精细的粒度检测发生异常的位置。 其操作与通过VM部署的应用程序类型无关。 此外，它还处理了运行时系统正常行为的频繁更改。 每个VM的并行分析使该方法可扩展到组成应用程序的大量VM。 该方法包括两个在线步骤：1）通过数据流聚类对群集集进行增量更新，以及2）计算表征全局群集演化的两个属性。 我们在VMware vSphere测试平台上验证了我们的方法。 它托管了一个典型的云应用程序MongoDB，我们将在正常行为情况下以及异常情况下进行研究。

**关键词**：
关键字-异常检测，数据流群集，云计算，服务，MongoDB。

## 总结
1. 没细看
2. 聚类算法，检测CPU等的值，称作计数器。
3. 启发：都是在区分状态，聚类算法需要定义状态间距离的算法
4. 监控的变量：
   1. CPU消耗率
   2. 未使用的内存
   3. 磁盘交换
   4. 网络包丢失率
   5. 网络延迟

# Adaptive Failure Prediction for Computer Systems: a Framework and a Case Study计算机系统的自适应故障预测：框架和案例研究


**时间**：
**杂志**：
**摘要**：

摘要—在线故障预测可以通过在运行时预见传入的故障来提高系统的可靠性，从而可以提前采取缓解措施。 尽管最近几年取得了进步，但由于执行支持操作（如培训，测试和调优）所需的复杂性和时间，在线故障预测仍未被采用。
   而且，随着目标系统在其运行期间的不断发展，必须经常对其进行重新训练以保持其有效性，这需要大量的人工干预和努力。 在这项工作中，我们提出了一个用于故障预测系统的自动部署和在线再培训的框架。 该框架利用诸如故障注入和虚拟化之类的关键技术来降低培训成本和影响，并由触发整个过程的可配置事件驱动。 我们提供了一个使用Web服务器系统的案例研究，我们的结果表明，即使在修改系统后，该框架也能够保持故障预测器的性能，这表明它在实际场景中很有用。

**关键词**：

关键词：在线故障预测 故障注入； 自适应故障预测； 虚拟化

## 一，引言


   一些工作解决了使用软件故障注入在短时间内获得故障数据来训练故障预测算法的问题，以加速故障发生并减少训练预测器所需的时间（[4] – [7]）。 虚拟化也已用于协助故障注入活动：将故障注入目标的虚拟副本中，从而消除了注入目标系统的需要，并防止了由故障注入导致的故障影响和破坏实际目标系统[6]  ，[8]。
   训练和优化故障预测器本质上是手动过程（例如[9] – [11]），并且需要很长时间[5]。 当故障预测应用于长期运行且不断发展的系统时，此问题将变得更加严重。
   一些工作（例如，[9]）已经表明，随着预测性能随着时间的推移而下降（例如，在系统更新之后），商业系统中需要更新故障预测算法。 到目前为止，还没有集成的故障预测框架可以解决所有这些难题，尤其是那些与在随时间变化的系统中连续使用故障预测有关的难题。
   我们为故障预测系统的自动和连续自适应提供了一个框架，从而降低了重新培训的成本，适用于系统随时间变化和变化的场景。 我们的框架是为通用目标系统定义的，可以针对特定系统实施。 它以完整的概念结构形式提供：体系结构，涉及的基本过程（培训，测试，故障注入和故障数据收集等）以及实施指南。 我们在Web服务器环境中提供示例实现。 该框架带来以下主要贡献：

   •该框架支持自动自适应以适应不断发展的系统。 基于模块化事件驱动的体系结构，故障预测器（重新）训练过程是自动化的，以检测何时需要重新训练。 事件是系统中某些事物的发生，可能会影响预测性能。 该框架是可配置的，可满足用户需求和目标系统的特殊性，从而支持用户对事件的定义。
   •框架使用软件故障注入来减少训练预测器所需的时间。
   通过注入故障，我们加快了故障的发生，使过去故障数据的收集变得可行。 我们注入软件故障，因为这些故障会导致基于计算机的系统中的大多数故障[12]。
   为了确保故障是现实的和相关的，我们使用[13]中的故障模型和注入技术：通用软件故障注入技术（G-SWFIT）。
   •该框架使用虚拟化环境对故障注入过程进行了沙盒处理，从而避免了在实际目标系统中注入故障的需要。
   在实际目标系统运行过程中注入故障会导致不可接受的副作用。
   使用虚拟化环境，故障注入会在目标系统的沙盒副本中进行。 目标副本执行的工作量模仿原始目标系统中执行的操作，以使收集的故障数据保持现实。

   该框架可在遵循所提供准则的具体目标系统中使用，并调整依赖于预期目标系统的部分（例如，在目标副本上执行的工作量和要注入的故障）。 该文件包括一个针对Web服务器系统的案例研究实现，表明该框架使预测器的性能保持较高且恒定不变，而人工干预较少，并降低了培训成本。
   在本文的其余部分安排如下。 下一节介绍了我们工作的核心概念，而第3节介绍了与此工作相关的作品。 第4节介绍了框架方法。 第5节向Web服务系统展示了该框架的案例研究实现的详细信息，包括其执行和结果讨论。 第7节总结并总结了本文。


## 二。 背景概念

A.故障预测在线故障
预测器会根据来自系统的过去数据（用于训练预测器）以及有关系统当前状态的信息（通过监视系统变量获得）来预测运行时传入的故障。 所使用的信息可以是数字的，例如测量系统属性的变量（空闲内存，页面错误等），也可以是分类的，例如错误日志中的事件。
   到目前为止，还没有关于故障预测问题的具体定义：[14]中提出了唯一的尝试为故障预测问题定义通用模型的故障预测模型。 故障预测任务包括评估在时间t是否会在精确的时间内（称为提前期Δtl）发生故障。 该预测可以在一个称为预测窗口Δtp的时间窗口内有效。 参数Δtl和Δtp的变化会影响预测的性能。 实际上，在时间t，模型（或预测变量）应预测在[t + ∆tl，t + ∆tl + ∆tp]间隔内是否将发生故障。
   故障预测系统的性能可以使用几个指标来表征。 在[14]和[8]中作者将指标分为两个系列。 第一个家庭的指标基于列联表的概念。 当预测故障将在某个间隔内发生时，如果故障事件在该间隔内至少发生一次，则该预测是正确的，这对应于“真正值”（TP）； 如果未发生任何故障，则为误报（FP）。 双重情况为真阴性（TN）–未检测到故障且未发生故障；假阴性（FN）–未预测到故障，但有一个发生。 从这四种情况得出的其他度量标准是，例如，准确性，预测，召回率，F度量[14]。 第二个族的度量标准基于对预测变量决策阈值分析的分析：预测通常是一个数值，失败或不失败的情况取决于该值是否高于（或低于）阈值，通常是 可调的。 不同的阈值会导致预测器的行为和性能不同。 特别是，在变化时绘制真实阳性率（TP /（TP + FN）或灵敏度或召回率）与错误阳性率（FP /（TN + FP）或1-特异性或假阳性率）的关系图 该阈值允许建立接收器工作特性（ROC）或曲线[15]，并计算ROC-AUC度量。


   故障预测取决于故障建模，故障检测和故障编码。 关于计算机系统中发生的故障建模的工作很少，例如C.R.A.S.H. 操作系统故障的规模[16]。 到目前为止，故障建模以及故障检测都是一个开放性问题，并且可以严格依赖于特定的系统。
   故障编码是故障事件与一组故障相关数据的关联。 编码方法取决于个人的需求以及所使用的预测技术的种类。 例如，当使用分类器时，必须将故障数据划分为样本，并且每个样本应标记为0（例如，无故障）或1（例如，故障）。
   使用从收集到的数据构建的数据集来训练故障预测器，将故障信息与数据关联（故障编码），并将它们组织在训练数据集（TDS）和测试数据集（TTDS）中，后者在训练预测器后用于评估 其预测性能。 根据问题，按照一定的百分比对训练和测试集中进行划分（例如，一半的数据样本用于训练，另一半用于测试）。 应执行有关测试算法优化和结果验证的其他任务：由于数据集包含几个具有不同重要性的变量（特征）[17]，选择最佳变量可提高预测质量（特征选择）  。 此外，预测变量的参数会影响其预测：生成的数据还必须用于找到针对特定情况的最佳参数。 最后，为了评估结果的可信度，应使用不同的数据集评估每个预测变量，从而确保预测变量实现的最佳性能不依赖于特定的数据集。

   B.软件故障注入
   故障是假设的错误原因（错误的系统内部状态），可能导致系统故障[18]。 故障注入，即以模拟真实故障的方式将故障故意插入系统[19]，是许多工作中使用的一种众所周知的方法，在这些工作中，观察存在故障的系统非常重要，例如故障 公差和可靠性机制验证，以及可靠性基准测试[20]。 软件故障（例如，编程错误）被认为是计算机故障的主要原因[21]，[22]，因此是与我们工作相关的故障类型。
   一项旨在理解和识别实际故障以及如何更改代码以仿真故障的研究导致了我们在当前工作中使用的G-SWFIT技术[13]。 注入故障的真实性是基于对编译器如何将高级语言转换为处理器指令的观察，而故障类型的代表性则是基于对故障的现场研究，该故障更可能在运行中的软件中发现。 阶段[13]。 这项技术与我们特别相关，因为我们需要在预测器的训练阶段观察实际的故障，并且实际注入代表软件中存在的故障的故障有助于对导致的故障实现真实感。
   可以通过故障类型，故障位置（即注入故障的位置）和注入时间（即注入故障的时间）来识别注入的故障。 此类故障可以组织成故障负载。 可以使用可用的技术（例如，[13]，[23]）来生成故障负载，并且故障负载中应该包含很可能被激活的位置中的故障，以进一步增加故障率的发生并减少收集数据所需的时间 。  （例如[24]）。

## 三， 相关工作

已经提出了几种类型的在线故障预测技术（参见[14]中的调查）。 其中，Salfner等。  Hughes等人[25]提出了一种基于系统状态聚类和使用隐式半马尔可夫模型来预测易发生故障的系统状态的方法。  [11]和Fulp等。  [26]应用SVM来预测基于Linux的计算机集群中硬盘驱动器的故障。  Irrera等。  [5]提出了一种基于支持向量机和滑动窗口的故障预测算法，评估了其在Windows XP OS中预测故障的有效性。
   据我们所知，解决将在线故障预测方法适应不断发展的系统的问题的工作很少，而且将故障预测方法适应不断发展的系统也不是一件容易的事（这些方法并非为此类系统设计的）。 该问题首先在[9]中得到了证明，其中研究了一种改进的SVM模型的行为，该行为预测了运行Tomcat Web服务器的Windows XP OS的挂起和崩溃故障。 该工作表明，对Tomcat Web服务器的连续更新导致整个目标系统的更改，并且应该使用新数据对预测变量进行重新训练。
   尽管其作者使用故障注入来生成在短时间内获得故障数据后，整个再培训过程仍然需要大量的人工干预。


## IV。 计算机系统自适应故障预测的框架

自适应故障预测框架（AFP框架）的最终目标是随着时间的推移保持故障预测器的最佳性能。 因此，AFP框架的关键方面是其自我适应动态（变化）目标的能力。 框架检测何时不再可接受一个或多个故障预测器的性能，并自动对其进行重新培训。 以下是框架的关键：面向事件的体系结构，对用户需求的可配置性，故障注入辅助的故障数据收集，沙盒培训和自动化。

•可配置的面向事件的体系结构：AFP框架由面向事件的逻辑驱动。 事件触发框架中负责确定是否需要重新培训的部分。
   这种逻辑避免了盲目重新培训，节省了系统资源和性能成本。 用户可以配置AFP框架使用的事件，该事件还可以配置特定的反应。
   •故障注入辅助的故障数据收集：AFP框架利用实际的软件故障注入来人为地造成实际的故障。
   注入的故障是软件故障，因为它们被认为是导致系统故障的主要原因（[21]，[22]）。
   •沙盒故障预测器的重新培训：我们无法在AFP框架所针对的系统中注入故障，因为这将（如预期的那样）导致系统故障，可能损坏数据，降低可用性等。因此必须在 目标系统的克隆，而不是系统本身。 为了适应这种情况，AFP框架利用虚拟化环境来托管目标系统的克隆。 所有故障注入，数据收集和再培训都是使用系统的虚拟化副本执行的，从而可以为真实系统提供不间断的服务。
   •自动化：将用户干预的需求降到最低，AFP Framework自动执行：i）生成故障数据，ii）目标系统副本上的故障注入活动，iii）通过外部复制工具复制目标系统 iv）在副本系统上执行工作负载，v）预测失败模型的训练，测试和更新，vi检测更新事件。

### A. AFP框架架构
AFP框架必须按模块组织，每个模块都有特定的关注点，以便改善所需的几个操作之间的编排，并有可能以独立的方式实现每个关注点。

 1）故障预测模块

 该模块的作用包括故障预测系统的管理。 这些操作包括故障检测，数据集中收集的数据的组织，故障编码，最后是预测变量的训练和执行（运行时预测）。 我们建议使用Salfner等人定义的故障预测模型。
   在[14]中，因为这允许执行明确地定义发生故障的预期时间（即提前期）的预测。 因此，故障预测将取决于几个参数，其中包括前置时间和预测窗口（∆tl，∆tp）。 此外，我们提出了一种基于标签的故障编码，该编码特定于分类器预测器，但可以适用于其他类型的预测器。 故障预测模块从目标系统及其副本收集数据。 从副本读取的数据用于训练，而在目标系统执行期间从目标系统读取的数据在运行时用于预测故障。  AFP框架利用与故障事件相关的数据（故障数据），以及描绘系统正常行为的数据（黄金数据）。 收集的数据被分为多个样本，每个样本在收集样本的瞬间被采样，并以<v1（t），v2（t），…，vN（t）>的形式表示（其中v（t）为值 在时间t读取的单个变量的值）。 每个样本都有一个0或1标签，标签1表示在[t + ∆tl，t + ∆tl + ∆tp]间隔内发生故障，标签0表示在该间隔内未发生故障。 为每个（∆tl，∆tp）元组标记训练数据集，从而得出| ∆tl |×| ∆tp |。 数据集。 预测是在运行时对连续读取的数据执行的：由于这个原因，用户必须定义​​要在其上执行预测的数据缓冲区（例如10秒的数据）。

### 2）绩效评估模块
该模块负责故障预测器性能的表征。 收集每个故障预测器的输出，并将其用于计算根据要评估的属性选择的一组度量（第II.A节）。
   在多个框架操作中需要评估（例如，训练故障预测，验证是否需要再训练）。 在这里，我们建议将ROC-AUC与F-Measure一起用作评估故障预测系统的主要指标。 原因在于两者都涉及故障预测问题的最相关方面，即：1.预测故障比预测不存在故障更为重要，因此必须最大化TP；  2.必须避免误报，因为失败会造成严重后果，因此必须将FN降至最低；  3.必须将FP最小化，因为总是会发信号通知故障并不能真正预测到。
   ROC分析的目标是最大程度地提高召回率（第II.A节）并最大程度地减少误报率。 通过使用ROC分析，可以确定用于实现所需操作行为（根据召回率和误报率）的阈值。 我们还建议ROC分析，因为它与数据集特征无关，并且易于解释和使用。 当使用不平衡的数据集（即，
   预测的事件数在百分比上不相等，这是在失败预测方案中的情况，失败的情况要少于未失败的情况。 还使用Fmeasure度量标准，因为它能够根据所有预测情况（例如，仅预测0和1的预测器）之间的平衡来发现ROC不能预测的预测器的异常行为。 特别地，小于0.1的FMeasure值意味着预测器可能在预测期间发生了一些问题（例如，仅预测0s）。 尽管如此，必须使用ROC分析得出的最佳阈值来计算F度量，这是特定预测变量的最佳工作点。

### 3）软件故障注入模块
该模块负责按故障负载组织副本系统中的软件故障注入，这允许注入任务的自动化。 选择最合适的故障负载是一个重要的话题，这很大程度上取决于目标系统。 我们建议使用GSWFIT技术[13]来模拟实际的软件故障，并在运行中组织故障注入活动。
   注入故障的执行称为故障注入运行。 如果在故障注入运行期间观察到故障，则表明该运行为故障运行，并且监视的数据称为故障数据（FD）。 运行也可能不包括故障注入：没有注入故障的运行称为黄金运行，相应的数据称为黄金数据（GD）。
   应遵循以下准则来定义故障负载：i）应根据有关目标系统中发现的各种故障的信息来选择故障类型；  ii）应该通过对目标系统的执行进行性能分析来标识故障位置，以标识具有较高执行概率的位置（以增加故障激活和故障概率）；  iii）由于可能存在许多故障，因此必须根据策略限制故障负荷的数量或至少对其进行分类（例如，故障可能占据每种类型的相等部分，甚至只是激活概率较高的那些部分）  ）。
### 4）沙箱模块
沙箱管理器负责创建和管理目标系统副本，并在沙箱环境中托管它。 我们建议使用裸机（I类）管理程序作为沙箱虚拟化环境，以减少虚拟化机与托管虚拟化环境的服务器硬件之间的交互。 实际上，尽管也可以使用II型虚拟机管理程序，但是在这种情况下生成的故障数据可能会受到虚拟化层的影响，如[6]中突出显示的那样。

图1。

### 5）工作量管理模块
该模块允许在目标系统的虚拟副本中部署，启动和停止工作负载。 选择最合适的工作负载是一个重要的主题，它非常取决于目标系统。 建立工作负载的一种方法是收集，研究和分类由目标系统执行的各种操作，然后使用定制的或现有的软件来重现它们。 来自标准基准测试（例如SPEC，TPC等）的工作负载通常会提供实际的工作负载（这是使故障预测适应目标系统的一项重要要求），并且可以在可用的情况下使用。
### 6）事件管理器模块
该模块负责检测事件并触发故障预测器的重新训练，并检查是否确实需要更新预测器。 图1中显示了一个模式。该模块的性质是可自定义的，即插即用，可创建新事件（例如，超时，系统配置已更改等）和新的特定反应。 管理器检测到发生的事件，调用相对于接收到的事件的反应，并最终重新训练预测器。 然后，该模块将新训练的预测器的性能与预测器的先前版本进行比较，以更新改进的预测器。
### B. AFP框架运作阶段
AFP框架的生命周期包括三个阶段：准备阶段（用户选择故障预测系统，要监视的变量等），执行阶段（故障预测和事件检查）以及训练阶段（执行几个阶段） 框架执行期间的时间。
   准备阶段包括框架用户必须执行的一组操作，以准备框架的执行。 最初，用户设置模块并安装和配置虚拟机监控程序。 用户还必须确定系统变量，以监视，安装和配置监视基础结构和故障注入工具，定义工作负载并定义事件和事件发生的反应行为。 在此阶段结束时，将启动框架。
   执行阶段包括对目标系统的连续监视，并检查事件的发生以重新训练故障预测器。 它分为：1.数据收集和故障预测：AFP框架使用监视工具连续从目标系统收集数据。 故障预测器使用数据执行预测任务。
   2.事件检查：框架检查定义的事件中是否发生了任何事件。 当检测到事件时，AFP Framework通过调用与检测到的事件相关的默认或自定义过程来启动更新（请参见图1）。
   3.故障预测器的（重新）训练和更新：执行重新训练操作（或简单地在框架启动时进行训练），保留先前版本的


重新训练的预测器准备就绪时，预测器在运行。 重新训练预测器后，会将其性能与仍在工作的预测器进行比较，如果最近训练的预测器性能更好，则会对其进行更新。
   培训阶段包括对一个或多个失败预测因子的培训。 此阶段执行的步骤是：1.目标系统复制：目标系统是
克隆到虚拟机并由框架用户配置，包括安装故障注入，监视工具和工作负载。
   2.数据生成和收集：在系统的虚拟化副本的上下文中执行。 多次执行此步骤，以从副本系统收集数据。 每个步骤都是一个运行，其中：i）工作负载在系统启动并达到稳定状态后执行（即，所有系统资源均已准备就绪，可以使用）；  ii）在工作负载开始之前就启动了监视基础结构；  iii）注入了故障；  iv）重新启动目标系统以避免影响的传播（在某些情况下，可能有必要重新安装整个系统，例如，注入的故障会永久损坏系统）。 收集故障数据（FD）和黄金数据（GD）。
   3.数据集构建：从收集的数据构建数据集，并与故障信息（标签）相关联。 失败数据标记为0和1，而黄金数据仅标记为0。 数据通过训练（以训练预测变量）和测试数据集（以测试预测变量）进行组织。 请注意，测试数据仍然是预测器训练阶段的一部分。
   4.预测器培训：使用生成的数据集对故障预测系统进行培训。 收集每个预测变量的输出以供以后分析。 该阶段可以分为三个步骤：i）训练，其中使用标签数据（训练数据）训练故障预测算法，以将故障与非故障情况区分开；  ii）测试，其中每个故障预测变量都试图标记一组未标记的数据（测试数据）；  iii）收集产品，收集生产的标签。
   5.指标计算和性能分析：每种算法的预测用于计算一组指标，这些指标是根据每个预测变量必须解决的性能特征（例如，高TP和低FP）选择的。


## V.TOMCAT Web服务器的自适应故障预测：案例研究

在本节中，我们使用支持向量机（SVM）分类器介绍AFP框架的实现，该分类器预测运行Apache Tomcat服务器应用程序（目标系统是OS）的Web服务器系统的故障。 该Web服务器在Citrix XEN虚拟机管理程序中托管为虚拟机，并且预测器使用数值变量来预测故障。

A. AFP框架的实现AFP框架的体系结构如图2所示。
   AFP Framework模块在控制器机器上实现，并与安装在目标及其副本上的工具进行远程通信，例如，监视工具收集在目标系统上安装的数据，以及故障注入工具，其安装在副本系统上并远程安装 由控制器管理。 控制器使用本地数据库存储收集的故障数据，故障预测结果和性能指标。
   故障预测模块利用安装在目标系统上的监视工具及其副本来收集数据，这些数据存储在控制器数据库中，并用于培训和运行时预测。 预测也存储在数据库中，因此可以轻松计算性能。 我们采用了C.R.A.S.H.  [16]中的模型，因为预测器旨在预测来自OS的故障。
   目标副本包含一个实施G-SWFIT技术的软件故障注入工具，可在运行时将软件故障注入运行中的系统。 当系统执行通过故障时，即激活故障，即，将模拟故障的指令加载到要执行的CPU中。  G-SWFIT定义了用于注入各种可能的故障（模型为正交缺陷分类– ODC [27]）的注入算子，并定义了有用的子类。 表I列出了注入的故障类型和相关ODC类的摘录。使用许多可用的商业工具之一，即Luke Stackwalker，完成了目标分析。 故障负载已建立

   由我们的故障注入工具自动执行，该工具会在目标的特定组件中搜索可以注入特定故障类型的故障位置。
   目标Web服务器系统及其副本都托管在Citrix XEN虚拟机管理程序中。  XEN虚拟机管理程序允许快速复制目标系统，而没有太多开销。  XEN虚拟机管理程序随附用于VM管理的客户端模块，该模块安装在控制器上并实现沙箱管理模块。
   作为副本系统的工作量，我们选择实现TPC-W工作量，其中TPC-W是基准测试交易Web服务系统的标准规范[28]，工作量部分以 在线书店，通常用于基准测试。 工作负载包括客户端，这些客户端要求服务器执行各种操作。 因此，这种工作量是现实的工作量。 客户端在控制器系统上进行仿真，并对Tomcat Web服务器执行浏览和购买操作。 为了简单起见，TPC-W工作负载也在目标系统上执行。
   事件管理模块也实现在控制器上。 我们定义了ROC-AUC低于某个阈值时触发的“ Tomcat版本更新”事件和“低预测性能”事件。 故障预测模块本身会定期对ROC-AUC值进行检查。 与事件一起，我们实施了一种反应，可以重新训练预测器，而实际的预测器仍在工作。

   

   B.初步实验评估我们在网络服务器系统案例研究中对FPA框架进行了实验评估。 实验包括在Apache Tomcat Web服务器上运行的SVM故障预测器，该服务器在其生存期内从5.5.36版本更新到6.0.2版本。 该框架会在Web服务器更新后立即重新训练预测变量，以使其适应新的目标系统配置。
   每个系统的特征如下：•虚拟机管理程序：Intel i5-650@3.60GHz（四核），8GB RAM，500GB HDD，运行XEN Server 6.2版。
   •目标系统（及其副本）：4个VCPU，4GB RAM，50GB HDD，在Windows XP（SP3）上运行Tomcat。
   •控制器系统：运行Windows 7 OS（SP1）的Intel i5-650@3.60GHz计算机，8GB RAM。
   为了加快框架评估的速度，我们使用了两个分离的测试平台，每个测试平台由一个控制器，一个目标和一个沙箱组成。 每个目标都从安装了Tomcat的基本版本开始，然后为每台计算机执行一个更新。 我们研究了AFP框架对“ Tomcat版本更新”和“低预测性能”事件的反应。 在我们的实验评估中，我们验证了目标系统中训练有素的故障预测因子，在其中注入故障以引起新的故障。 这样做仅出于实验评估和验证目的。
   AFP框架是为Windows环境实现的。 这里使用的SVM实现是libSVM

   [29]，还实现了滑动窗口增强，从而提高了对输入数据加窗的预测质量[30]。 我们使用了一个宽度为3秒的滑动窗口（有关详细信息，请参见[5]）。 我们改编了C.R.A.S.H. 缩放模型以观察到的故障，即系统挂起（操作系统挂起并且必须终止），对应于规模项Catastrophic。 通过向操作系统发送几个命令来进行故障检测：如果没有响应，则假定操作系统已挂起。
   监视模块由Windows操作系统家族中的Logman工具制成。 我们在每个目标计算机中监视了170个数字变量，这些变量的值指示OS资源的状态。 这些变量以每秒一个值的速率采样。
   作为故障注入的目标，我们选择了由svchost.exe程序和services.exe在Windows中实现的用户与OS交互层，以及kernel32.dll和ntdll.dll系统模块。 在开始执行工作负载后（大约基于分析测试配置的启动时间定义的值），在大约70秒的时间注入一次故障。 为了增加激活故障的可能性，将注入的故障留在系统中，直到运行结束。 在注射运行结束时，系统将恢复。
   目标连接到包含书店数据的Oracle DBMS版本11g。 特别是，测试台1中的目标连接到安装在外部虚拟机上的Oracle DB（托管在XEN群集中），而测试台2中的目标则在本地托管Oracle DB。 在测试平台＃1的情况下，Oracle数据库也被克隆。
   复制系统（用于培训）和目标系统（用于验证）都在预定时间段T（约4分钟）内运行TPC-W工作负载，然后重新启动。 重复N次（请参阅表II）。 在每次运行期间，我们一次注入一个故障，然后收集故障数据。 运行工作负载时不会注入任何故障来收集黄金数据。
   注入故障时，如果在时间间隔T中发生故障（考虑到系统调度程序，可能会有一定的时间公差（在我们的示例中为10％，考虑到潜在的延迟），则该运行将标记为“故障运行”。


C.结果
所执行的方案列于表II。 每个Tomcat版本，目标系统执行的TPC-W工作量介于500到800次之间，因此＃1测试台运行约1600次运行，＃2测试台共运行1200次。 我们在两个目标中总共观察到约30个挂起，仅在＃1测试台上发生了7次崩溃。 由于不能保证注入的故障的故障位置在实际执行的代码内，因此故障的数量可能会很少[13]。 预测的失败预测提前时间Δtl在10到30秒之间，预测窗口Δtp为5或10秒。 选择这些值来模拟现实的Web服务场景。 通过使用故障注入，我们能够在不到250小时的时间内导致35个故障（测试台2）。 我们试图将此数据与在线提供的Windows XP OS故障数据进行比较，这种数据很少且不完整。 在[31]中对Microsoft产品进行的一项研究表明，Windows XP OS具有600个小时的MTTF，该值同时考虑了OS和应用程序故障。 从这个角度来看，即使仅考虑OS故障，使用故障注入也会将故障数据的收集减少两个数量级。
   在图3中，我们介绍了SVM预测器的性能，该性能可预测正在研究的两个测试台的目标系统上的故障。 由于空间限制，我们仅针对参数（∆tl，∆tp）=（10s，10s）分析预测器性能。 平均而言，此行为与此处介绍的情况相同。  x轴是在目标系统上发生故障时所测量的时间：对于每个发生的故障，预测器根据参数（Δtl，∆tp）标记每个数据样本，然后将预测结果与实际故障发生时间进行比较 。  y轴是ROC-AUC值。 发生的事件是“低预测性能”（LP）和“ Tomcat从版本A更新到版本B”（请参阅​​表II）。 框架对事件LP进行了重新训练预测器（R1）的反应，然后对事件更新事件进行了第二次重新训练（R2）的反应，恢复了预测性能。 在两个测试平台上发生两次系统更改事件后，恢复了预测器性能。
   每次重新培训都是完全自动化的，大约需要3天，主要用于收集故障数据，而培训，测试和更新故障预测器仅需几分钟。
## VI。 结论和未来工作
这项工作解决了自动化和自动化的问题。支持工作负载的自动生成以及将准则扩展到其他类别的系统。




# 模板



**时间**：
**杂志**：
**摘要**：

**关键词**：

# 模板



**时间**：
**杂志**：
**摘要**：

**关键词**：
