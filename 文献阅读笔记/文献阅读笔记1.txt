
# 模板



**时间**：
**杂志**：
**摘要**：

**关键词**：

# Software Reliability Engineering - A Review软件可靠性工程-回顾
软件可靠性工程-回顾

**时间**：2011年9月
**杂志**：International Journal of Applied Physics and Mathematics
**摘要**：
略
**关键词**：
reliability， waterfall ，prototyping ，incremental，rapid，evolutionary，agile
可靠性，瀑布模型，原型制作，增加的，快速，进化，敏捷

## 总结

1. 里面有传统可靠性的浴盆曲线和理想化的软件可靠性曲线。
2. 有常见的软件开发模型的简介，有瀑布模型、原型制作、增量开发、螺旋发展、快速应用开发（RAD）、进化发展方法、Rational统一过程、基于组件的软件开发。
3. 有计算机辅助软件工程、IDE、敏捷开发（极限编程XP、Scrum）的简介。
4. 至于文章本身提出的那个东西，就是说要先建模算一算可靠性，直接算可能有困难。但是啥有用的东西都没有。

# Deterministic Models of Software Aging and Optimal Rejuvenation Schedules软件老化和最佳复兴计划的确定性模型
软件老化和最佳复兴计划的确定性模型

**时间**：2007
**杂志**：
**摘要**：
研究对象：服务器Axis Soap Server 1.3
对老化建模，从而进行Rejuvenation。SLA约束、

建模算法：样条插值拟合
**关键词**：

## 总结

1. 在介绍中提到了老化、Rejuvenation的介绍，两种基本的Rejuvenation思路：定时，积极（根据建模）。
2. 用某些指标来评价老化：服务器每秒可处理的最大请求数。
3. 假设性能下降与负载有关的函数。假设模型可以足够精确的建模。
4. 介绍了建模思路：分析建模和基于度量建模
5. 建模过程：分段用样条拟合
6. 假设老化指标只取决于单个负载指标。或者多个负载指标的简单函数。
7. 用方差分析进行了模型验证
8. 改进了方差分析法，引入了方差容忍度
9. 分析了如何得出最佳Rejuvenation的时间，此处没有细看
10. 实验通过10台客户端连接1台服务器来注入负载。
11. 收集的系统参数有：
  + free memory：available memory in the JVM of the SOAP
server
  + cpu_user： % of CPU time used by the user applications,
  + cpu_system：操作系统使用的CPU时间的百分比，
  + cpu_idle：CPU空闲的时间的百分比，
  + request_per_sec：SOAP服务器的吞吐量，以每秒执行的请求数为单位，
  + min_lat：请求延迟最小观测值
  + maxlat：请求延迟最大观测值
  + avg lat：请求延迟平均值。
12. 实验方法：以超过服务器容量的某一个固定值持续加压
13. 老化指标：每秒请求数。负载指标：经选择，用了自上次重启以来的请求数。
14. 图像的曲线都是很平滑的，先上升，然后缓慢单调下降的样子。【随着总请求数越来越多，每秒的请求就越小，老化了。】

# Basic Concepts and Taxonomy of Dependable and Secure Computing可靠和安全计算的基本概念和分类
可靠和安全计算的基本概念和分类

这篇好像是大佬的综述
**时间**：2004
**杂志**：IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING, VOL. 1, NO. 1, JANUARY-MARCH 2004 
**摘要**：
就是各种定义。
**关键词**：
Dependability, security, trust, faults, errors, failures, vulnerabilities, attacks, fault tolerance, fault removal, fault forecasting
可靠性，安全性，信任性，故障，错误，故障，漏洞，攻击，容错，故障消除，故障预测
## 总结

非常详尽的定义

# Detecting Application-Level Failures in Component-Based Internet Services在基于组件的Internet服务中检测应用程序级故障
在基于组件的Internet服务中检测应用程序级故障

作者一个是斯坦福的，一个是MIT的
**时间**：2005
**杂志**：IEEE TRANSACTIONS ON NEURAL NETWORKS, VOL. 16, NO. 5, SEPTEMBER 2005 
**摘要**：
大多数Internet服务（电子商务，搜索引擎等）都存在故障。
快速检测这些故障可能是提高系统可用性的最大瓶颈。
我们介绍方法Pinpoint，一种通过以下方法在Internet服务中自动进行故障检测的方法：1）观察服务的底层内部结构行为； 2）将系统的多数行为建模为正确； 3）将这些行为中的异常检测为故障的可能症状。
不需要任何先验的特定于应用程序的信息，Pinpoint在我们的实验中正确地检测出了89％–96％的重大故障，与此同时，当前的通用应用技术检测出了20％–70％。
**关键词**：
Anomaly detection, application-level failures, Internet services.
异常检测，应用程序级别的故障，Internet服务。

## 总结

1. 研究的是应用程序级的故障：会影响用户可见的一些功能，但是不会引起系统崩溃一类的运营商可检测到的系统级故障
2. 无需先验信息，对正常状态进行建模。
3. 监控内部组件的trace形状：客户请求后经过的部件名称。监控部件之间的交互情况。
4. 实验对象：J2EE应用程序
5. 主要关注在故障发生后尽快检测到
6. 监测方法：写在了J2EE上
7. 故障注入研究，参考文献4,18-21，列举了一部分，没有详细步骤
8. 计算P的时候通过min(0, score-a)过滤掉大于a的一些值
9. 组件交互的计数与请求路径分析有一定程度上的互补。
10. 用PCFG对路径进行了建模，从这里就与我的研究无关了。
11. 本篇有简略译文。


# A Measurement-Based Model for Estimation of Resource Exhaustion in Operational Software Systems基于测量的运营软件系统资源枯竭估计模型
基于测量的运营软件系统资源枯竭估计模型

**时间**：1999
**杂志**：
**摘要**：

主要研究软件老化。本文考虑了系统的工作负荷，函数的自变量之一。本文提出了一个基于度量的模型，来估计操作系统资源的耗尽率，自变量为时间和工作负载状态。用基于Unix系统收集到的工作量和资源使用情况构建了半马尔科夫奖励模型。先用统计聚类分析对工作量的状态进行了聚类，然后根据每种在不同状态下的资源枯竭率，为该模型定义奖励函数。然后求解该模型以获得**趋势**以及资源的估计**耗尽率**和**耗尽时间**。


**关键词**：

## 总结

1. 研究老化，主要原因：操作系统资源的耗尽，数据损坏和数字错误累积。导致系统崩溃或挂起。
2. 常见情况：**内存膨胀和泄漏**，**未释放的文件锁**，数据损坏，存储空间碎片以及舍入错误的累积
3. 预测资源消耗的时候考虑了工作负载。
4. 相关工作中提到：
   1. 时间为变量预测系统资源的方法
   2. 有一些文献说明了资源、负载与失效的相关性。
   3. 别的工作负载指标：CPU使用率、内存使用率
   4. 性能的单词用了performability
5. 马尔科夫不太懂，没有细看。简单的说，应该是预测一个状态到另一个状态转换的概率。
6. 10分钟一次，监控了3个月：系统资源状态、进程状态、文件系统信息【/tmp】、网络相关、磁盘IO，共100多个此类参数【和sar的差不多，只不过多了进程信息？】
7. 要预测的值：usedSwapSpace和realMemoryFree。建模用的数据是最长的采样时间内的数据【重启或发生了故障则重新采样】
8. 工作负载的表示：工作负载与CPU和I/O有关，故采用cpuContextSwitch【测量间隔内，进程的上下文切换数量】、sysCall【系统调用数】、pageIn【从文件系统或交换设备分页的页面数，就叫page-in】、pageOut
9. 对于每个工作负载的点【相当于一个四维空间的点】进行聚类，算法用的Hartigan【一种k-means聚类算法】。聚类发现一些状态时轻量工作状态，一些是高负载。
10. 计算状态转移概率【通过简单除法】，构建转移矩阵。半马尔科夫好像还要状态持续时间，反正根据分布大概定了一个？然后验证了一下结果，效果很不错。
11. 这里有点看不懂了，反正是通过奖励函数，利用半马尔科夫模型对要预测的两个值进行了预测
12. 计算斜率的方法[20]：这个斜率好像是大量样本的总斜率，跟我要的不一样。
13. 最后这个结果有点迷，看不懂


# A Best Practice Guide to Resource Forecasting for Computing Systems计算系统资源预测的最佳实践指南
计算系统资源预测的最佳实践指南

**时间**：2007
**杂志**：
**摘要**：
在本文中，我们基于预测Apache Web服务器性能变量以及预测实际电信系统的呼叫可用性的经验，提出了建立经验模型的最佳实践指南。为了证实所提供的指南，并逐步演示我们的方法，我们对**响应时间**，Apache Web服务器系统的**可用物理内存**量以及工业电信系统的呼叫call可用性进行建模和预测。此外，我们为a）基准交叉验证三个**变量选择**的方法，b）基准交叉验证四个**经验模型构建**的方法以及c）**敏感性分析**  提供了具体的结果。本最佳实践指南旨在协助系统地配置建模方法，以实现最佳估计和预测结果。

**关键词**：
Apache web server, failure forecasting, monitoring,
non-parametric modeling, prediction of resource utilization,
quantitative analysis, statistical modeling, telecommunication
systems.

Apache Web服务器，故障预测，监视，非参数​​建模，资源利用预测，定量分析，统计建模，电信系统。

## 总结

1. 本篇文献非常有用，基本上阐述了在当时的常用方法，并进行了总结，还有完整的实验和分析
2. Introduction里的很多也非常有用，可以直接用
3. 补丁、更新会把测试过的系统编程未测试的系统，引入新的错误，所以需要预测
4. 预测了Apache服务器中的响应时间和可用物理内存。电信系统的那个例子没细看。
5. 主要过程：数据选择【向前选择，向后消除，PWA概率包装】，建模【**多元线性回归、UBF、RBF、SVM**】，敏感性分析【删除一个看看模型的指标怎么样，后来发现敏感性与目标值的相关性关系不大】
6. 选择好的数据子集要比选模型重要的多
7. 介绍了大量之前别人用过的模型，文献
8. 数据集分成了三份，【按时间分的？从图上看是这样的】将第一段用于参数化模型，第二部分对模型进行交叉验证并限制过度拟合，第三部分用于对模型的泛化性能进行评估。一二段都喂给模型
9. 数据有峰值，处理方法：一段时间窗口内的中位数median，感觉平均值也行？或者就是平均值？
10. 数据：系统变量一类的和网络相关的，还有一阶导数
11. 响应时间预计：
    1. 实际数据：整体缓慢上升，有非常多的峰值，整体是个锯齿
    2. 中位数处理后，整体单调上升，最后一段略微下降一点点就平了
    3. 大概每6h有一次峰值
    4. 短期预计选出来的变量有：
       1. 新进程数
       2. 硬盘写入块数
       3. eh0_trans_pkts
       4. lo_recv_pkts
       5. SwapOutCounter
       6. si_slab_cache
       7. si_size_256
       8. ContextSwitches的导数
       9. CachedMemory的导数
    5. 长期的变量有：
       1. 新进程数
       2. eh0_recv_pkts
       3. ContextSwitches
       4. TimeIdelMode
       5. io_trans_bytes
       6. SwapInCounter
       7. si_size_256
       8. si_size_32
       9. ContextSwitches的导数
12. 可用内存预计
    1. 数据趋势：先下降，然后到一个地方后开始上升
    2. 变量有：
       1. t-1时刻的可用物理内存
       2. TimeUserMode
       3. 新进程数的导数
       4. si_files_cache

# Quantifying Temporal and Spatial Correlation of Failure Events for Proactive Management量化故障事件的时间和空间相关性以进行主动管理

量化故障事件的时间和空间相关性以进行主动管理

**时间**：2007
**杂志**：
**摘要**：

故障事件在时空方面表现出很强的相关性。 在本文中，我们开发了具有可调时标参数的**球形协方差模型**以量化时间相关性，并建立了随机模型以表征空间相关性。 进一步扩展了模型，以考虑到应用程序分配的信息，以发现故障实例之间的更多关联。 我们根据故障事件的相关性对它们进行聚类，并预测其未来的发生。
在生产联盟系统Wayne State Grid上的实验结果表明，我们的预测系统进行的离线和在线预测可以预测72.7％至85.3％的故障发生，并捕获集群联盟环境中的故障相关性。

**关键词**：

## 总结
1. 主要考虑的是故障之间的时间相关性和空间相关性
2. 时间相关性：a.短时间内多个节点同时发生一个故障；b.故障在解决前多次出现
3. 空间相关性：a.故障几乎同时发生在多个节点上【一个程序要用多个节点，有bug都得坏】；b.节点故障会导致别的节点的另一种故障【一个坏了会传错误数据】
4. 实验对象，他们学校的一个计算集群，最小单位就是一台计算机……
5. 收集的信息：失效签名：内存、CPU、I/O、包
6. 聚类算法？
7. 失效是个重尾分布，而且软件故障最严重（相比于硬件和全部）
8. 时间相关性：用时间差衡量距离，定义了一个球形协方差矩阵【没看懂】
9. 空间相关性：主要是计算失效数，拿概率算的。
10. 离线预计算法4+1：MEAN：以先前度量的平均值作为预测；  LAST：使用最后一个度量；  AVE（n）：使用最近n个小节的平均值；  AR（m）：是自回归的； 一种人工神经网络算法NN（n），使用最后n个数据来更新神经网络并预测故障【3个隐藏层】。
11. 在线预计：拿0~t的数据来预测，然后对比t~T的结果。

# Online Reliability Prediction via Motifs-Based Dynamic Bayesian Networks for Service-Oriented Systems面向服务的系统通过基于Motifs的动态贝叶斯网络进行在线可靠性预测
面向服务的系统通过基于Motifs的动态贝叶斯网络进行在线可靠性预测


**时间**：2016
**杂志**：IEEE Transactions on Software Engineering
**摘要**：

面向服务的系统系统（SoS）将系统视为服务，并通过服务组合技术外包外部组件系统来构建健壮的增值SoS。 为了应对在动态和不确定的运行环境下运行的松耦合SoS，为确保整体服务质量（QoS）的目的而对组件系统进行在线可靠性预测通常是一个重大挑战。 这也是通过优化服务选择以确保可靠的系统构建来保证SoS的运行时QoS的前提。 我们为面向服务的SoS中的组件系统提出了一种新颖的在线可靠性时间序列预测方法。 我们利用概率图形模型（PGM）来产生接近未来的时间序列预测。 我们通过从广泛使用的真实Web服务中收集的调用记录来评估该方法。 实验结果证实了该方法的有效性。


**关键词**：Index Terms—Online reliability prediction, time series, service-oriented computing, system of systems

索引词-在线可靠性预测，时间序列，面向服务的计算，系统系统

## 总结

1. 本文没有详细阅读
2. 主要是针对System of Systems，好像会有一些独特的问题，本文重点在预测可靠性
3. 在线可靠性时间序列预测
4. 历史参数：响应时间，吞吐量，可靠性，用概率图像模型PGM分析。对历史参数预处理，分成等长的时间序列。然后用主题的概念来描述时间序列的模式。然后用马尔科夫表达序列间的关系，生成条件概率表CPT，CPT与PGM一起用于预测。主要是基于动态贝叶斯网络，整合了时间序列。
5. 论文15中有简要介绍





# Seer: A Lightweight Online Failure Prediction Approach 一种轻量级的在线故障预测方法
Seer：一种轻量级的在线故障预测方法

**时间**：2017
**杂志**：IEEE Transactions on Software Engineering
**摘要**：

**关键词**：

## 总结
1. 从程序内部收集信息会产生过多的运行时开销，所以现有方法通常会避免使用
2. Seer是通过硬件性能计数器（HPC）来收集数据的，在硬件层面收集数据，如CPU驻留计数器来收集执行的指令数和采取的分支数量
3. 与此同时还可以结合系统层次收集到的进程数、CPU、内存、网络利用率来加强预测效果
4. 现在大部分的预测都是把软件当黑盒子，可以考虑白盒拿到更内部的数据。不这么做的主要问题是开销太大。
5. 本文未精读。
6. 先把历史数据输入，然后选出一些可以在运行时监控的函数，然后从这些函数的历史数据里收集信息，用于识别


## 方法
seer从函数级别收集内部的执行数据，由两部分组成：一个离线的训练阶段和一个在线的监控阶段。训练阶段用历史数据当输入，历史数据包括通过和失败的执行。首先，监控系统执行的函数，过滤函数来决定候选函数，候选函数要在运行时可以被监控。然后，从每一个候选函数的历史执行数据中收集混合光谱bybrid spectra。接下来，收集到的光谱被用于确定可以预测失效的函数。为此，每一个候选函数，都需要构建一个二元分类器的预测模型。然后，表现最好的函数标记为seer 函数，即能最好的区分失败执行和通过执行的。最后，seer函数用他们的预测模型来增强，并且将仪表系统部署到监视阶段。


在监视阶段，每次调用Seer函数后，在调用过程中收集的混合光谱将馈送到Seer函数的预测模型，以便对执行的未来进行二进制预测（即通过或失败） 制造。 然后在运行时分析在固定长度窗口中进行的先知预测的顺序，以预测故障的表现。 如果预测执行失败，则会发出警告，提示可能即将发生的失败。 一旦发出警告，便可以采取积极措施。 但是，这些措施不在本工作范围之内。 此外，我们主要关注这项工作中的功能故障，而不是非功能故障。








