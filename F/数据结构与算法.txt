清华邓俊辉
# 1. 绪论
## a. 计算
计算是研究对象，要挖掘规律、技巧
也是研究目标，实现高效、低耗的计算

+ 计算 = 信息处理
借助某种工具，遵照一定规则，以明确而机械的形式进行
+ 计算模型 = 计算机 = 信息处理工具
+ 所谓算法，即特定计算模型下，旨在解决特定问题的指令序列
  + 输入：待处理的信息（问题）
  + 输出：经处理的信息（答案）
  + 正确性：的确可以解决指定的问题
  + 确定性：任一算法都可以描述为一个由基本操作组成的序列
  + 可行性：每一基本操作都可实现，且在常数时间内完成
  + 有穷性：对于任何输入，经有穷次基本操作，都可以得到输出
+ 好算法
  + 正确：符合语法，能够编译、链接
  + 健壮：能够辨别不合法的输入并做适当处理，而不致非正常退出
  + 可读：结构化 + 准确命名 + 注释 + ...
  + **效率**：速度尽可能快；存储空间尽可能少
## b. 计算模型
+ 算法分析
  两个主要方面
  + 正确性
  + 成本：运行时间 + 所需存储空间
+ 考察$T_A(P)$ = 算法A求解问题实例P的计算成本
意义不大，实例太多
+ 问题的规模往往是决定成本的主要因素（不绝对）
主要讨论时间成本
$T(n)$ = 用特定算法A求解某一规模为n的实例，所需要的计算成本
但是有时候运气因素会影响计算成本，稳妥起见，考虑最坏情况（成本最高）

+ 对特定问题的不同算法的评价：
为了给出客观评判，抽象出一个理想的平台或模型：图灵机（Turing Machine）、RAM（Random Access Machine）
可以将**算法运行时间**转化为**算法需要执行的基本操作次数**
## c. 大O记号
+ 关心的问题：随着问题规模的增长，计算成本如何增长？
注意：这里关心规模足够大之后，注重考察成本的增长趋势
+ 渐进分析：在问题足够大之后，计算成本如何增长
+ 大O记号（big-*O* notation）
   $T(n)=O( f(n) )$,  iff【if and only if】、 ∃c > 0，当n >> 2【>>：远大于】后，有$T(n) < c * f(n)$``
+ 与T(n)相比，f(n)更简洁，但依然反映前者的增长趋势，是T(n)的一个上界
  + 常系数可忽略
  + 低次项可忽略
+ 渐进分析：其他记号
+ bigΩ：$T(n)=Ω( f(n) )$：$∃c > 0$，当n >> 2后，有$T(n) > c * f(n)$，是T(n)的一个下界
+ bigΘ：$T(n)=Θ( f(n) )$：$∃c_1>c_2 > 0$，当n >> 2后，有$c_1 * f(n)>T(n) > c_2 * f(n)$

**一般考虑悲观情况，大O，特定情况下才考虑Ω和Θ**
+ O(1)
常数复杂度，这类算法的效率最高
+ O(logn)
对数复杂度，或对数多项式复杂度。
  + 常底数无所谓。不用注明底数
  + 常数次幂无所谓
  + 对数多项式（ploy-log function），对数的多项式，可以参照普通多项式，忽略低次项
  + 这类算法非常有效，复杂度无限接近于常数
+ O($n^c$)
多项式复杂度
  + 线性：O(n)
  + 这类算法的效率通常认为已可令人满意
+ O($2^n$)
指数复杂度
  + 这类算法的计算成本增长极快，通常被认为不可忍受
  + 从O($n^c$)到O($2^n$)，是从**有效算法**到**无效算法**的分水岭
## d. 算法分析
+ 两个主要任务 = 正确性（不变性 × 单调性） + 复杂度
+ 高级语言的基本指令，通常等效于数条RAM的基本指令，在渐进意义下，二者大体相当
+ 复杂度分析的主要方法
  + 迭代：级数求和
  + 递归：递归跟踪 + 递推方程
  + 猜测 + 验证
### 级数
+ 算术级数：与末项平方同阶
$$
T(n) = 1 + 2 + ... + n = \frac{n(n+1)}{2} = O (n^2)
$$

+ 幂方级数：比最高幂次高出一阶
$$
T_2(n) = 1^2 + 2^2 + ... + n^2 = \frac{n(n+1)(2n+1)}{6} = O (n^3)
$$

+ 几何级数( a > 1 )：与末项同阶
$$
T_a(n) = a^0 + a^1 + ... + a^n = \frac{a^{n+1}-1}{a-1} = O (a^n)
$$

+ 收敛级数
$$
1 + \frac{1}{2^2} + ... + \frac{1}{n^2} < 1 + \frac{1}{2^2} + ... = \frac{π^2}{6} = O(1)
$$

+ 可能未必收敛，然而长度有限
  + 调和级数
$$
h(n) = 1 + \frac{1}{2} + \frac{1}{3} + ... + \frac{1}{n} = Θ(logn)
$$

  + 对数级数
$$
  log1 + log2 +log3 + ... + logn = log(n!) = Θ(nlogn)
$$

### 循环和级数
+ 例1
``` 
    for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
        O1Operation(i,j); //O(1)操作
```
算数级数：
$$
n + n + ... + n = n * n = O(n^2)
$$
相当于一个正方形的面积
+ 例2
```
    for (int i = 0; i < n; i++)
    for (int j = 0; j < i; j++)
        O1Operation(i,j);
```
算数级数：
$$
0 + 1 + ... + (n-1) = \frac{n(n-1)}{2} = O(n^2)
$$
相当于一个三角形的面积
+ 例3
```
    for (int i = 0; i < n; i++)
    for (int j = 0; j < i; j+= 2013)
        O1Operation(i,j); 
```
算数级数：
相当于j的坐标轴做了一个压缩：j/2013，依旧是一个三角形，$O(n^2)$
+ 例4
```
    for (int i = 0; i < n; i <<= 1) //i左移一位，相当于i = 2i
    for (int j = 0; j < i; j+= 2013)
        O1Operation(i,j);
```
几何级数：
$$
1 + 2 + 4 + ... + 2^{|log_2(n-1)|} = 2 ^{|log_2n|} - 1 = O(n)
$$
相当于一个螺旋增加正方形的面积，最后的面积是2n
【https://www.bilibili.com/video/av49361421?p=12 的最后】
### 取非极端元素例子
无论输入规模n多大，算法需要的执行时间都不变
### 起泡排序分析
+ 不变性：经k轮扫描交换后，最大的k个元素必然就位
+ 单调性：经k轮扫描交换后，问题规模缩减至n-k
+ 正确性：经至多n趟扫描后，算法必然终止，且能给出正确答案【由不变性和单调性推导得出】
### 封底估算
1天 = 10^5 sec
1生 = 1世纪 = 3 × 10^9 sec
三生三世 = 10^10 sec
宇宙大爆炸至今 = 10^21 sec
普通PC 1GHz 10^9 flops
## e. 迭代与递归
问题：数组求和，迭代
实现：
```
    int SumI(int A[], int n){
    int sum = 0; //O(1)
    for (int i = 0; i < n; i++)  //O(n)
        sum += A[i]; //O(1)
    return sum; //O(1)
    }
```
时间复杂度：T(n) = n + 2 = O(n)
空间：一般不考虑输入本身所需要占用的空间，本题为O(2)

### 减而治之【Decrease-and-conquer】
### 递归跟踪（recursion trace）分析
### 递推方程
+ 递归基
### 分而治之【Divide-and-conquer】

## f. 动态规划
+ DSA（Data Structure and Algorithm）的设计优化：make it work, make it right, make it fast. - Kent Beck
+ 前两步，递归的构思；最后一步，迭代
+ 所谓的动态规划，可以理解成用递归给出一个初步的解之后，再通过迭代提高效率。

### fib()：递归
`int fib(n) { return (2 > n) ? n : fib(n-1) + fib(n-2); }`
n稍大就特别大
分析：
$$
递推分析：T(0)=T(1)=1; T(n)=T(n-1)+T(n-2)+1,n>1\\
令S(n)=[T(n)+1] / 2\\
则S(0)=1=fib(1),S(1)=1=fib(2)\\
故S(n)=S(n-1)+S(n-2)=fib(n+1)\\
T(n)=2*S(n)-1=O(fib(n+1)）=O（Φ^n）=O(2^n)
$$
#### 封底估算：
+ $Φ^{36} = 2^{25}$
  + $Φ^{43} = 2^{30} = 10^9 flo = 1 sec$
+ $Φ^{5} = 10$
  + $Φ^{67} = 10^{14} flo = 10^5 sec = 1 day$
  + $Φ^{92} = 10^{19} flo = 10^10 sec = 3 century$
#### 递归跟踪分析：
各递归实例被大量重复地调用，如fib(2)会被计算很多很多次
#### fib()：迭代
解决方法A：记忆memoization，将已计算过实例的结果制表备查
解决方法B：动态规划dynamic programming
颠倒计算方向：由自顶而下递归，改为自底向上迭代

```
    f = 0; g = 1;
    while(0 < n--){
        g = g + f;
        f = g - f;
    }
    return g;
```
g和f永远代表了相邻的两个斐波那契数
T(n)=O(n)，而且仅需要O(1)空间！

### LCS(Longest Common Subsequence最长公共子序列):递归
```
0) 若n = -1或m = -1，则取作空序列("") //递归基
1) 若A[n] = 'X' = B[m],则取作LCS(A[0,n),B[0,m)) + 'X'  //减而治之
2) 若A[n] ≠ B[m]，则在LCS(A[0,n],B[0,m))与
                    LCS(A[0,n),B[0,m])中取更长者  //分而治之
```
单调性：无论如何，每经过一次比对，原文提的规模必可减小
具体的，作为输入的两个序列，至少其一的长度缩短一个单位

最好情况下（只出现第一种情况）下，只需O(n+m)时间
但问题在于，在第2种情况下，原问题将分解为2个子问题，而它们在随后进一步导出的子问题可能雷同【有点像fib问题，同一个子问题会被重复计算很多次】

最坏情况下，LCS(A[0, a], B[0, B])出现的次数为
$$
C_{n-a}^{n+m-a-b} = C_{m-b}^{n+m-a-b}
$$
>子问题LCS(A[0, a], B[0, B])出现的次数可以看作是从原问题出发（右下角(n,m)），有多少条路径会走到(a,b)这个点
>n+m-a-b的含义是n-a+m-b，是路径的总长度
>n-a和m-b分别是水平的长度和竖直的长度

特别的，LCS(A[0],B[0])的次数可多达
$$
C_{n}^{n+m} = C_{m}^{n+m}
$$
当n=m时，为O(2^n)
#### LCS：迭代
0) 将所以子问题列成一张表
1) 颠倒计算方向，从LCS(A[0],B[0])出发依次计算出所有项

|      |      |  a   |  b   |  c   |  d   |  e   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |  0   |  0   |  0   |  0   |  0   |
|  a   |  0   |  1   |  1   |  1   |  1   |  1   |
|  p   |  0   |  1   |  1   |  1   |  1   |  1   |
|  p   |  0   |  1   |  1   |  1   |  1   |  1   |
|  l   |  0   |  1   |  1   |  1   |  1   |  1   |
|  e   |  0   |  1   |  1   |  1   |  1   |  2   |

# 2. 向量
## a. 接口与实现
Abstract Data Type抽象数据类型 = **数据模型** + 定义在该模型上的**一组操作**
Data Structure数据结构 = 基于某种**特定语言**，实现ADT的**一整套算法**
### 向量ADT
+ 数组
数组中每个元素由（非负）编号唯一指代，并可以直接访问，A[i]的物理地址 = A + i × s
亦称作线性数组（linear array）
+ 向量
数组的抽象和泛化，由一组元素按线性次序封装而成

_size，_capacity，_elem
## b. 可扩充向量
+ 递增式扩容：
初始为0的空向量，插入 n = m*I >> 2个元素
每次扩容时间成本O(n)
+ 加倍式扩容：
初始为0的空向量，插入 n = 2^m >> 2个元素
每次扩容时间成本O(1)

+ 平均分析 vs. 分摊分析
  + 平均复杂度（期望复杂度）
  根据数据结构各种操作出现的概率分布，将对应的成本加权平均。
    各种可能的操作，作为独立事件分别考察，割裂了操作之间的相关性和连贯性
  + 分摊复杂度
  对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作
    从实际可行的角度，对一系列操作做整体的考量，更加忠实地刻画了可能出现的操作序列，更精准地评判数据结构和算法的真是性能

## c. 无序向量
T为可**判等**的基本类型，或已重载操作符“==”或“!=”
### 循秩访问
### 插入
注意复制从后往前
### 区间删除
复制从前往后
### 查找
从hi开始逆向查找，输入敏感：最好O(1)，最差O(n)
### 单元素删除
视作区间删除的特例[r]=[r,r+1)
### 唯一化
前缀中寻找雷同者，无雷同继续考察后继，有雷同则删除
O(n^2)
### 遍历
## d. 有序向量
T为可**比较**的基本类型，或已重载操作符“>”或“<”
### 甄别：
相邻逆序对的数量，0为有序
### 唯一化
首元素开始，从前往后逐一比对，雷同删除后者，否则向后
O(n^2)

首元素开始，往后比对，跳过雷同者，发现不同时，向前移至紧邻于前者右侧，统一删除尾部
O(n)
### 二分查找
#### 接口
search(e,lo,hi)
#### 语义
为了插入方便，约定：失败给出新元素适当的插入位置；若允许重复，每次都应该给出最后或最前的秩，以使得元素次序与插入次序吻合

#### 原理（不完全符合语义）
算法A：
x=S[mi]
lo<hi
e<x，左侧
x<e，右侧
e=x，返回

O(logn)

#### 查找长度
更精细地评估查找算法的性能，考察关键码的比较次数
分别针对成功、失败，从最好、最坏、平均等角度评估
算法A成功、失败时的平均查找长度大致为O(1.5logn)

#### fib查找
取mi = fib(k-1) - 1，左边长fib(k-1) - 1，右边长fib(k-2) - 1

#### 复杂度
以A[λn]为轴点分割，二分查找为λ=0.5，Fibonacci查找对应于λ=φ=0.6180339...
设平均查找长度为α(λ)*log_2(n)，根据递推式求极限，λ=φ时，α(λ)=1.4404...最小

### 二分查找改进
版本B：
1< hi-lo
e<x：左侧[lo,mi)
x<=e：右侧[mi,hi)
相比于A，最好时更坏，最坏时更好，性能更趋稳定
**版本C：**
考虑到语义，多个命中元素，返回最靠后者；失败是，返回小于e的最大者（含哨兵[lo-1]）
lo<hi
e<x：[lo,mi)
x<e：(mi,hi)
## e. 起泡（冒泡）排序
bubbleSort
O(n^2)
### 改进：
1. 设置整体有序标志 sorted，初值为true；若发生交换，置为false。
2. 若有一次未发生交换，则直接停止
乱序限于[0,根号n)时，仍然需要O(n^1.5)
### 再改进：
1. 设置一个秩last = lo，若逆序，交换时更新last，最后记录最右侧逆序对的位置
2. 下次bubble就只需要在[lo,last]之间进行即可
### 综合评价
起泡排序的三个版本在最好O(n)和最坏O(n^)时的性能是一样的，差异只在一般情况下而言。
起泡排序算法都具有稳定性：重复元素在输入、输出序列中的相对次序是不变的
## f. 归并排序
基于比较式的算法C.B.A(comparision based algorithm)求解排序算法都存在下界Ω(nlogn)
### 原理
分治策略：序列一分为二，子序列递归排序，合并有序子序列
O(nlogn)
### 主算法
递归基：hi-lo<2，单元素区间，自然有序
中点分界，递归两个序列
归并merge()
### 二路归并
关注两个序列的首元素，每次取出首元素中更小的那个元素，后续元素进行顶替
### 实现
我们这里用的其实是一个特例，两个有序向量都来自于一个更大的序列
三个界桩：lo,mi,hi
A[lo,hi) = B[lo,mi) + C[mi,hi)
B新申请一段空间，A不需要，C也不需要
```
    for (i,j,k=0;(j<lb)||(k<lc)){  //退出条件：B、C元素都越界才退出
        if( (j<lb)&&(lc<=k ||(B[j]<=C[k])) ) A[i++]=B[j++]; //取出BC中更小的放入A。B更小的判断：j首先还在B里；然后如果k不在C了，短路算法直接true，如果k还在，判断大小
        if( (k<lc)&&(lb<=j ||(C[k]<B[j])) ) A[i++]=C[k++];  //取出BC中更小的放入A
    }
```
### 复杂度
j+k=n【每次迭代j+k至少+1（每次循环中可能j会先变，然后会执行2条if）】
最坏情况下merge()复杂度为O(n)

# 3. 列表
### 从静态到动态
+ 根据是否修改数据结构，所有的**操作**大致分为两类：
1. 静态：仅读取，数据结构的内容及组成一般不变：get、search
2. 动态：需写入，数据结构的局部或整体将改变：insert、remove
+ 与操作方式相对应，数据元素的**存储与组织方式**也分为两种：
1. 静态：
   数据空间整体创建或销毁
   数据元素的物理存储次序与逻辑次序严格一致
   可支持高效的静态操作
   例如向量
2. 动态：
   为各数据元素动态地分配和回收的物理空间
   逻辑上相邻的元素记录彼此的物理地址，在逻辑上形成一个整体
   可支持高效的动态操作
### 列表list
动态存储的典型结构
+ 基本组成单位：节点 node
+ 相邻接点互称彼此为 前驱（predecessor） 或 后继（successor）
+ 没有前驱/后继的唯一节点称作 首（first/front）/末（last/rear） 节点
### 访问方式
+ 向量：循秩访问call by rank
+ 列表：循位置访问call by position，由节点之间的互相引用找到特定的节点
## 无序列表
### 循秩访问
O(n)
### 查找
顺序查找：O(n)
### 插入
O(1)
### 删除
O(1)
### 唯一化
